#include <stdio.h>

int n;
int dp[1001][10]; //dp[A][B] = C, A길이의 숫자에서 가장 마지막 숫자가 B일때, 가능한 오르막 수 갯수는 C개

int main(void)
{
    scanf("%d", &n);

    for(int i = 0; i < 10; i++) //1자리 수인 0 ~ 9는 그 자체로도 오르막 수가됨, 즉 전부 길이가 1이며, 가장 마지막 숫자
        dp[1][i] = 1;

    //2자리 이상부턴 마지막 숫자에 영향을 받음. 예를들어 dp[2][2]가 있을때 두자리 숫자면서 끝 숫자가 2인경우
    //n 2의 형태를 띄는데 n에 들어갈 수 있는 숫자는 0, 1, 2이다. 따라서 dp[2][2] 갯수는 3개이다.
    //수식으로 표현하면 dp[2][2] = dp[1][0] + dp[1][1] + dp[2][2]이다
    //이러한 과정을 반복해 점화식을 구해보면 dp[n][k] = dp[n-1][0] + dp[n-1][1] + ... + dp[n-1][k]가 나온다.
    for(int i = 2; i <= n; i++) //2 ~ n자리 숫자들에 대한 오르막수를 계산하기 위한 for문
    {
        for(int j = 0; j < 10; j++) //가장 마지막 숫자가 0 ~ 9인 경우들에 대한 오르막 수를 계산하기 위한 for문
        {
            for(int k = j; k >= 0; k--) //가장 마지막 숫자에 따라서 발생할 수 있는 오르막 수를 계산하기 위해서 N - 1번째 오르막수 들에서 0 ~ K번째 값을 계산하기 위한 for문
            {
                dp[i][j] = dp[i][j] + dp[i - 1][k];
                dp[i][j] = dp[i][j] % 10007;
            }
        }
    }

    int sum = 0;
    for(int i = 0; i < 10; i++)
        sum = sum + dp[n][i]; //경우의 수 합산
    sum = sum % 10007;

    printf("%d\n", sum);

    return(0);
}