#include <iostream>

int change_val(int& p)
{
    p = 3;
    return 0;
}

int main(void)
{
    int a = 3;
    int& another_a = a; //참조자란 a의 별명을 지어주는 것과 같다.
    //즉, another_a에 작업하는 것들은 a를 작업하는 것과 같다.
    //레퍼런스(참조자)를 정의할 때는 위처럼 누구의 별명인지 지정해야한다.

    another_a = 5;
    std::cout << "a : " << a << std::endl;
    std::cout << "another_a : " << another_a << std::endl;

    /* ******************************************************************************** */

    //함수로 레퍼런스 정의하기
    int number = 5;

    std::cout << "number : " << number << std::endl;
    change_val(number); //int& p = number과 일맥상통함.
    std::cout << "number : " << number << std::endl;

    /* ******************************************************************************** */
    
    //배열의 레퍼런스(주의 : 래퍼런스의 배열을 생성하는건 불가능! 오직 배열의 래퍼런스만.)
    int arr[3] = {1, 2, 3};
    int(&ref)[3] = arr; //포인터와는 다르게 배열의 레퍼런스의 경우 참조하기 위해선 반드시 배열의 크기를 명시해야 한다.

    ref[0] = 2;
    ref[1] = 3;
    ref[2] = 1;

    std::cout << arr[0] << arr[1] << arr[2] << std::endl;
}

/*
    레퍼런스가 메모리 상에 반드시 존재해야 하는 경우는 어떤 경우가 있을까요? 
    그리고 메모리 상에 존재할 필요가 없는 경우는 또 어떤 경우가 있을 까요? (난이도 : 上)
    
    ->어떤 사람의 답변 : 
    함수의 매개변수로 레퍼런스를 전달할 때는 주소를 전달한다라고 하셨는데,
    이것을 힙, 스택, 데이터 메모리 영역 분리 관점에서
    호출 스택이 추가될 때 주소값을 전달한다 라고 생각해도 될까요?

    같은 관점에서 생각해보기의 답으로
    1) 호출 스택이 달라질 때, 해당 메모리에 접근하기 위해 주소가 필요하다. 주소 메모리 공간이 필요하다.
    2) 호출 스택이 같을 때, 바로 접근하며 따로 주소 메모리 공간이 불필요하다.
*/