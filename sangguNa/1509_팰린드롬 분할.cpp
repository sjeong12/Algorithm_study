#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

string s;
int pld[2501][2501]; //pld[A][B] = 1 / 0: 주어진 문자열에서, A번문자부터 B번문자까지는 팰린드롬 문자열이 맞다(1)/아니다(0)
int dp[2501]; //dp[A] = B : A번 문자까지 팰린드롬 문자열로 분할 할 수 있는 최소 횟수는 B번이다

int main(void)
{
    cin >> s;
    s.insert(0, " ");
    
    int n = s.length(); //문자열의 길이 저장

    //문자열 길이 1일때 팰린드롬 분할 여부, 길이가 1일땐 자기 자신이므로 팰린드롬 분할이다.
    for (int i = 1; i <= n; i++)
    {
        pld[i][i] = 1;
    }
    
    //문자열 길이 2일때 팰린드롬 분할여부, 처음과 끝 문자가 같으면 팰린드롬 분할이다.
    for (int i = 1; i < n; i++)
    {
        if (s[i] == s[i + 1])
            pld[i][i + 1] = 1;
    }

    //문자열 길이 3일때 팰린드롬 분할여부
    //[첫번째 문자] [나머지 문자열] [마지막 문자] 세부분으로 나눌 수 있는데, 참이되려면
    //[첫번째 문자]와 [마지막 문자]가 동일해야하고 && [나머지 문자열]이 팰린드롬 문자열이여야 한다.
    //점화식으로 나타내면 String[Start] == String[End] && pld[Start + 1][End - 1] == true 일때 
    //pld[Start][end] = 1이다.
    for (int i = 2; i < n; i++)
    {
        for (int j = 1; j <= n - i; j++) //n - i 까지 j를 증가, 그냥 n을 하면 런타임에러 발생
        {
            if (s[j] == s[j + i] && pld[j + 1][j + i - 1])
                pld[j][j + i] = 1;
        }
    }

    for (int i = 1; i < n; i++) //end
    {
        dp[i] = 2147483647; //최대값 배정
        for (int j = 1; j <= i; j++) //start
        {
            if (pld[j][i] == 1)
            {
                dp[i] = min(dp[i], dp[j - 1] + 1);
                //"최소 분할 횟수" 이기 때문에, A ~ End번 문자열이 팰린드롬 문자열로 분할이 가능하다고 하더라도, 
                //기존에 구해놨던 최소횟수 중 더 작은 값이 있다면 갱신이 일어나면 안된다.
            }    
        }
    }
    // dp[End]의 값은, dp[A - 1] + 1
    //A ~ End번 문자로 이루어진 문자열인데, dp[A - 1]이라는 것은, 이 전에 나왔던 문자(1 ~ A - 1번 문자) 까지의 
    //팰린드롬 문자열로 분할할 수 있는 최소 횟수를 의미한다.
    //즉, dp[A - 1]번 문자까지 분할할 수 있는 최소 횟수로 분할한 후에, A ~ End번 문자열을 하나의 팰린드롬 문자열로 분할을 할 것이기 때문에,
    //결국 1 ~ End번 까지의 최소 분할 횟수는 dp[A - 1] + 1 이 된다는 것이다.

    cout << dp[n - 1] << endl;

    return 0;
}