#include <stdio.h>

int n; //밑변의 길이
int dp[31]; //dp[n] = m, 의미는 밑변의 길이가 n일때 타일링 할 수있는 경우의 수 m
int s[31]; //중복을 제거한, 타일링의 갯수.

/*
    문제에서 요구하는건 기존의 타일링 개수에서 중복을 제거하는 거였음.
    하지만 중복을 제거하는건 어려우므로, 반대로 중복되지 않는 갯수를 더한 후 2로 나누면 비교젹 쉽게 구할 수있음
    (A + 2B)였다면 (A + 2B + A)/2를 하는셈.
    길이가 홀수인 경우
        가운데에 2*1타일을 위치시킨 경우의 수 -> A = dp[i/2]
    길이가 짝수인 경우
        가운데에 2*1 타일 2개 | 1*2 타일 2개 | 2*2 타일 1개를 세우고 양쪽으로 대칭되게 위치시킨 경우의 수
        -> A = dp[i/2] + 2*dp[i/2 - 1] = dp[i/2 + 1]
*/
int main(void)
{
    scanf("%d", &n);

    dp[0] = dp[1] = 1;
    dp[2] = 3;

    for (int i = 3; i <= n; i++)
        dp[i] = dp[i - 1] + 2 * dp[i - 2]; // 2*n 타일링2에서 사용했던 점화식, 이를 이용해 초기화

    s[0] = s[1] = 1;
    s[2] = 3;

    for (int i = 3; i <= n; i++)
    {
        if ((i % 2) == 0) //i가 짝수의 경우
            s[i] = (dp[i] + dp[i/2 + 1]) / 2;
        else //i가 홀수인 경우
            s[i] = (dp[i] + dp[i/2]) / 2;
    }

    printf("%d\n", s[n]);

    return (0);
}